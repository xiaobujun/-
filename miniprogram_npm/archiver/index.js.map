{"version":3,"sources":["index.js","lib/core.js","lib/error.js","lib/plugins/zip.js","lib/plugins/tar.js","lib/plugins/json.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AENA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,ACHA,AGTA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AHUA,ACHA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AIZA,ADGA,ADGA;AFOA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Archiver Vending\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar Archiver = require('./lib/core');\r\n\r\nvar formats = {};\r\n\r\n/**\r\n * Dispenses a new Archiver instance.\r\n *\r\n * @constructor\r\n * @param  {String} format The archive format to use.\r\n * @param  {Object} options See [Archiver]{@link Archiver}\r\n * @return {Archiver}\r\n */\r\nvar vending = function(format, options) {\r\n  return vending.create(format, options);\r\n};\r\n\r\n/**\r\n * Creates a new Archiver instance.\r\n *\r\n * @param  {String} format The archive format to use.\r\n * @param  {Object} options See [Archiver]{@link Archiver}\r\n * @return {Archiver}\r\n */\r\nvending.create = function(format, options) {\r\n  if (formats[format]) {\r\n    var instance = new Archiver(format, options);\r\n    instance.setFormat(format);\r\n    instance.setModule(new formats[format](options));\r\n\r\n    return instance;\r\n  } else {\r\n    throw new Error('create(' + format + '): format not registered');\r\n  }\r\n};\r\n\r\n/**\r\n * Registers a format for use with archiver.\r\n *\r\n * @param  {String} format The name of the format.\r\n * @param  {Function} module The function for archiver to interact with.\r\n * @return void\r\n */\r\nvending.registerFormat = function(format, module) {\r\n  if (formats[format]) {\r\n    throw new Error('register(' + format + '): format already registered');\r\n  }\r\n\r\n  if (typeof module !== 'function') {\r\n    throw new Error('register(' + format + '): format module invalid');\r\n  }\r\n\r\n  if (typeof module.prototype.append !== 'function' || typeof module.prototype.finalize !== 'function') {\r\n    throw new Error('register(' + format + '): format module missing methods');\r\n  }\r\n\r\n  formats[format] = module;\r\n};\r\n\r\nvending.registerFormat('zip', require('./lib/plugins/zip'));\r\nvending.registerFormat('tar', require('./lib/plugins/tar'));\r\nvending.registerFormat('json', require('./lib/plugins/json'));\r\n\r\nmodule.exports = vending;","/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar fs = require('fs');\r\nvar glob = require('glob');\r\nvar async = require('async');\r\nvar path = require('path');\r\nvar util = require('archiver-utils');\r\n\r\nvar inherits = require('util').inherits;\r\nvar ArchiverError = require('./error');\r\nvar Transform = require('readable-stream').Transform;\r\n\r\nvar win32 = process.platform === 'win32';\r\n\r\n/**\r\n * @constructor\r\n * @param {String} format The archive format to use.\r\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\r\n */\r\nvar Archiver = function(format, options) {\r\n  if (!(this instanceof Archiver)) {\r\n    return new Archiver(format, options);\r\n  }\r\n\r\n  if (typeof format !== 'string') {\r\n    options = format;\r\n    format = 'zip';\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {\r\n    highWaterMark: 1024 * 1024,\r\n    statConcurrency: 4\r\n  });\r\n\r\n  Transform.call(this, options);\r\n\r\n  this._format = false;\r\n  this._module = false;\r\n  this._pending = 0;\r\n  this._pointer = 0;\r\n\r\n  this._entriesCount = 0;\r\n  this._entriesProcessedCount = 0;\r\n  this._fsEntriesTotalBytes = 0;\r\n  this._fsEntriesProcessedBytes = 0;\r\n\r\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\r\n  this._queue.drain = this._onQueueDrain.bind(this);\r\n\r\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\r\n\r\n  this._state = {\r\n    aborted: false,\r\n    finalize: false,\r\n    finalizing: false,\r\n    finalized: false,\r\n    modulePiped: false\r\n  };\r\n\r\n  this._streams = [];\r\n};\r\n\r\ninherits(Archiver, Transform);\r\n\r\n/**\r\n * Internal logic for `abort`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._abort = function() {\r\n  this._state.aborted = true;\r\n  this._queue.kill();\r\n  this._statQueue.kill();\r\n\r\n  if (this._queue.idle()) {\r\n    this._shutdown();\r\n  }\r\n};\r\n\r\n/**\r\n * Internal helper for appending files.\r\n *\r\n * @private\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data The entry data.\r\n * @return void\r\n */\r\nArchiver.prototype._append = function(filepath, data) {\r\n  data = data || {};\r\n\r\n  var task = {\r\n    source: null,\r\n    filepath: filepath\r\n  };\r\n\r\n  if (!data.name) {\r\n    data.name = filepath;\r\n  }\r\n\r\n  data.sourcePath = filepath;\r\n  task.data = data;\r\n  this._entriesCount++;\r\n\r\n  if (data.stats && data.stats instanceof fs.Stats) {\r\n    task = this._updateQueueTaskWithStats(task, data.stats);\r\n    if (task) {\r\n      if (data.stats.size) {\r\n        this._fsEntriesTotalBytes += data.stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n  } else {\r\n    this._statQueue.push(task);\r\n  }\r\n};\r\n\r\n/**\r\n * Internal logic for `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._finalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  this._state.finalizing = true;\r\n\r\n  this._moduleFinalize();\r\n\r\n  this._state.finalizing = false;\r\n  this._state.finalized = true;\r\n};\r\n\r\n/**\r\n * Checks the various state variables to determine if we can `finalize`.\r\n *\r\n * @private\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._maybeFinalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return false;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Appends an entry to the module.\r\n *\r\n * @private\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {EntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._moduleAppend = function(source, data, callback) {\r\n  if (this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._module.append(source, data, function(err) {\r\n    this._task = null;\r\n\r\n    if (this._state.aborted) {\r\n      this._shutdown();\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this.emit('error', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Fires when the entry's input has been processed and appended to the archive.\r\n     *\r\n     * @event Archiver#entry\r\n     * @type {EntryData}\r\n     */\r\n    this.emit('entry', data);\r\n    this._entriesProcessedCount++;\r\n\r\n    if (data.stats && data.stats.size) {\r\n      this._fsEntriesProcessedBytes += data.stats.size;\r\n    }\r\n\r\n    /**\r\n     * @event Archiver#progress\r\n     * @type {ProgressData}\r\n     */\r\n    this.emit('progress', {\r\n      entries: {\r\n        total: this._entriesCount,\r\n        processed: this._entriesProcessedCount\r\n      },\r\n      fs: {\r\n        totalBytes: this._fsEntriesTotalBytes,\r\n        processedBytes: this._fsEntriesProcessedBytes\r\n      }\r\n    });\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Finalizes the module.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleFinalize = function() {\r\n  if (typeof this._module.finalize === 'function') {\r\n    this._module.finalize();\r\n  } else if (typeof this._module.end === 'function') {\r\n    this._module.end();\r\n  } else {\r\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\r\n  }\r\n};\r\n\r\n/**\r\n * Pipes the module to our internal stream with error bubbling.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._modulePipe = function() {\r\n  this._module.on('error', this._onModuleError.bind(this));\r\n  this._module.pipe(this);\r\n  this._state.modulePiped = true;\r\n};\r\n\r\n/**\r\n * Determines if the current module supports a defined feature.\r\n *\r\n * @private\r\n * @param  {String} key\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._moduleSupports = function(key) {\r\n  if (!this._module.supports || !this._module.supports[key]) {\r\n    return false;\r\n  }\r\n\r\n  return this._module.supports[key];\r\n};\r\n\r\n/**\r\n * Unpipes the module from our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleUnpipe = function() {\r\n  this._module.unpipe(this);\r\n  this._state.modulePiped = false;\r\n};\r\n\r\n/**\r\n * Normalizes entry data with fallbacks for key properties.\r\n *\r\n * @private\r\n * @param  {Object} data\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._normalizeEntryData = function(data, stats) {\r\n  data = util.defaults(data, {\r\n    type: 'file',\r\n    name: null,\r\n    date: null,\r\n    mode: null,\r\n    prefix: null,\r\n    sourcePath: null,\r\n    stats: false\r\n  });\r\n\r\n  if (stats && data.stats === false) {\r\n    data.stats = stats;\r\n  }\r\n\r\n  var isDir = data.type === 'directory';\r\n\r\n  if (data.name) {\r\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\r\n      data.name = data.prefix + '/' + data.name;\r\n      data.prefix = null;\r\n    }\r\n\r\n    data.name = util.sanitizePath(data.name);\r\n\r\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\r\n      isDir = true;\r\n      data.type = 'directory';\r\n    } else if (isDir) {\r\n      data.name += '/';\r\n    }\r\n  }\r\n\r\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\r\n  if (typeof data.mode === 'number') {\r\n    if (win32) {\r\n      data.mode &= 511;\r\n    } else {\r\n      data.mode &= 4095\r\n    }\r\n  } else if (data.stats && data.mode === null) {\r\n    if (win32) {\r\n      data.mode = data.stats.mode & 511;\r\n    } else {\r\n      data.mode = data.stats.mode & 4095;\r\n    }\r\n\r\n    // stat isn't reliable on windows; force 0755 for dir\r\n    if (win32 && isDir) {\r\n      data.mode = 493;\r\n    }\r\n  } else if (data.mode === null) {\r\n    data.mode = isDir ? 493 : 420;\r\n  }\r\n\r\n  if (data.stats && data.date === null) {\r\n    data.date = data.stats.mtime;\r\n  } else {\r\n    data.date = util.dateify(data.date);\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\n/**\r\n * Error listener that re-emits error on to our internal stream.\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\r\nArchiver.prototype._onModuleError = function(err) {\r\n  /**\r\n   * @event Archiver#error\r\n   * @type {ErrorData}\r\n   */\r\n  this.emit('error', err);\r\n};\r\n\r\n/**\r\n * Checks the various state variables after queue has drained to determine if\r\n * we need to `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueDrain = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n};\r\n\r\n/**\r\n * Appends each queue task to the module.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._task = task;\r\n  this._moduleAppend(task.source, task.data, callback);\r\n};\r\n\r\n/**\r\n * Performs a file stat and reinjects the task back into the queue.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onStatQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  fs.lstat(task.filepath, function(err, stats) {\r\n    if (this._state.aborted) {\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this._entriesCount--;\r\n\r\n      /**\r\n       * @event Archiver#warning\r\n       * @type {ErrorData}\r\n       */\r\n      this.emit('warning', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    task = this._updateQueueTaskWithStats(task, stats);\r\n\r\n    if (task) {\r\n      if (stats.size) {\r\n        this._fsEntriesTotalBytes += stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Unpipes the module and ends our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._shutdown = function() {\r\n  this._moduleUnpipe();\r\n  this.end();\r\n};\r\n\r\n/**\r\n * Tracks the bytes emitted by our internal stream.\r\n *\r\n * @private\r\n * @param  {Buffer} chunk\r\n * @param  {String} encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._transform = function(chunk, encoding, callback) {\r\n  if (chunk) {\r\n    this._pointer += chunk.length;\r\n  }\r\n\r\n  callback(null, chunk);\r\n};\r\n\r\n/**\r\n * Updates and normalizes a queue task using stats data.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._updateQueueTaskWithStats = function(task, stats) {\r\n  if (stats.isFile()) {\r\n    task.data.type = 'file';\r\n    task.data.sourceType = 'stream';\r\n    task.source = util.lazyReadStream(task.filepath);\r\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\r\n    task.data.name = util.trailingSlashIt(task.data.name);\r\n    task.data.type = 'directory';\r\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\r\n    var linkPath = fs.readlinkSync(task.filepath);\r\n    var dirName = path.dirname(task.filepath);\r\n    task.data.type = 'symlink';\r\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else {\r\n    if (stats.isDirectory()) {\r\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\r\n    } else if (stats.isSymbolicLink()) {\r\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\r\n    } else {\r\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  task.data = this._normalizeEntryData(task.data, stats);\r\n\r\n  return task;\r\n};\r\n\r\n/**\r\n * Aborts the archiving process, taking a best-effort approach, by:\r\n *\r\n * - removing any pending queue tasks\r\n * - allowing any active queue workers to finish\r\n * - detaching internal module pipes\r\n * - ending both sides of the Transform stream\r\n *\r\n * It will NOT drain any remaining sources.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.abort = function() {\r\n  if (this._state.aborted || this._state.finalized) {\r\n    return this;\r\n  }\r\n\r\n  this._abort();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends an input source (text string, buffer, or stream) to the instance.\r\n *\r\n * When the instance has received, processed, and emitted the input, the `entry`\r\n * event is fired.\r\n *\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream|String)} source The input source.\r\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.append = function(source, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  data = this._normalizeEntryData(data);\r\n\r\n  if (typeof data.name !== 'string' || data.name.length === 0) {\r\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\r\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  source = util.normalizeInputSource(source);\r\n\r\n  if (Buffer.isBuffer(source)) {\r\n    data.sourceType = 'buffer';\r\n  } else if (util.isStream(source)) {\r\n    data.sourceType = 'stream';\r\n  } else {\r\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: source\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a directory and its files, recursively, given its dirpath.\r\n *\r\n * @param  {String} dirpath The source directory path.\r\n * @param  {String} destpath The destination path within the archive.\r\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.directory = function(dirpath, destpath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\r\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._pending++;\r\n\r\n  if (destpath === false) {\r\n    destpath = '';\r\n  } else if (typeof destpath !== 'string'){\r\n    destpath = dirpath;\r\n  }\r\n\r\n  var dataFunction = false;\r\n  if (typeof data === 'function') {\r\n    dataFunction = data;\r\n    data = {};\r\n  } else if (typeof data !== 'object') {\r\n    data = {};\r\n  }\r\n\r\n  var globOptions = {\r\n    stat: false,\r\n    dot: true,\r\n    cwd: dirpath\r\n  };\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var ignoreMatch = false;\r\n    var entryData = Object.assign({}, data);\r\n    entryData.name = match;\r\n    entryData.prefix = destpath;\r\n    match = globber._makeAbs(match);\r\n\r\n    try {\r\n      if (dataFunction) {\r\n        entryData = dataFunction(entryData);\r\n\r\n        if (entryData === false) {\r\n          ignoreMatch = true;\r\n        } else if (typeof entryData !== 'object') {\r\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', { dirpath: dirpath });\r\n        }\r\n      }\r\n    } catch(e) {\r\n      this.emit('error', e);\r\n      return;\r\n    }\r\n\r\n    if (ignoreMatch) {\r\n      return;\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob('**', globOptions);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a file given its filepath using a\r\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\r\n * prevent issues with open file limits.\r\n *\r\n * When the instance has received, processed, and emitted the file, the `entry`\r\n * event is fired.\r\n *\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.file = function(filepath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._append(filepath, data);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends multiple files that match a glob pattern.\r\n *\r\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/node-glob#glob-primer} to match.\r\n * @param  {Object} options See [node-glob]{@link https://github.com/isaacs/node-glob#options}.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.glob = function(pattern, options, data) {\r\n  this._pending++;\r\n\r\n  options = util.defaults(options, {\r\n    stat: false\r\n  });\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var entryData = Object.assign({}, data);\r\n\r\n    if (options.cwd) {\r\n      entryData.name = match;\r\n      match = globber._makeAbs(match);\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob(pattern, options);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Finalizes the instance and prevents further appending to the archive\r\n * structure (queue will continue til drained).\r\n *\r\n * The `end`, `close` or `finish` events on the destination stream may fire\r\n * right after calling this method so you should set listeners beforehand to\r\n * properly detect stream completion.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.finalize = function() {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.finalize) {\r\n    this.emit('error', new ArchiverError('FINALIZING'));\r\n    return this;\r\n  }\r\n\r\n  this._state.finalize = true;\r\n\r\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    var errored;\r\n\r\n    self._module.on('end', function() {\r\n      if (!errored) {\r\n        resolve();\r\n      }\r\n    })\r\n\r\n    self._module.on('error', function(err) {\r\n      errored = true;\r\n      reject(err);\r\n    })\r\n  })\r\n};\r\n\r\n/**\r\n * Sets the module format name used for archiving.\r\n *\r\n * @param {String} format The name of the format.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setFormat = function(format) {\r\n  if (this._format) {\r\n    this.emit('error', new ArchiverError('FORMATSET'));\r\n    return this;\r\n  }\r\n\r\n  this._format = format;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the module used for archiving.\r\n *\r\n * @param {Function} module The function for archiver to interact with.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setModule = function(module) {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.module) {\r\n    this.emit('error', new ArchiverError('MODULESET'));\r\n    return this;\r\n  }\r\n\r\n  this._module = module;\r\n  this._modulePipe();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a symlink to the instance.\r\n *\r\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\r\n *\r\n * @param  {String} filepath The symlink path (within archive).\r\n * @param  {String} target The target path (within archive).\r\n * @return {this}\r\n */\r\nArchiver.prototype.symlink = function(filepath, target) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof target !== 'string' || target.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  if (!this._moduleSupports('symlink')) {\r\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  var data = {};\r\n  data.type = 'symlink';\r\n  data.name = filepath.replace(/\\\\/g, '/');\r\n  data.linkname = target.replace(/\\\\/g, '/');\r\n  data.sourceType = 'buffer';\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: Buffer.concat([])\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the current length (in bytes) that has been emitted.\r\n *\r\n * @return {Number}\r\n */\r\nArchiver.prototype.pointer = function() {\r\n  return this._pointer;\r\n};\r\n\r\n/**\r\n * Middleware-like helper that has yet to be fully implemented.\r\n *\r\n * @private\r\n * @param  {Function} plugin\r\n * @return {this}\r\n */\r\nArchiver.prototype.use = function(plugin) {\r\n  this._streams.push(plugin);\r\n  return this;\r\n};\r\n\r\nmodule.exports = Archiver;\r\n\r\n/**\r\n * @typedef {Object} CoreOptions\r\n * @global\r\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\r\n * process the internal fs stat queue.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TransformOptions\r\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\r\n * will automatically end the readable side when the writable side ends and vice\r\n * versa.\r\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\r\n * into Buffers before passing them to _write(). `Writable`\r\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\r\n * to strings using the specified encoding. `Readable`\r\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\r\n * in the internal buffer before ceasing to read from the underlying resource.\r\n * `Readable` `Writable`\r\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\r\n * stream of objects. Meaning that stream.read(n) returns a single value instead\r\n * of a Buffer of size n. `Readable` `Writable`\r\n */\r\n\r\n/**\r\n * @typedef {Object} EntryData\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ErrorData\r\n * @property {String} message The message of the error.\r\n * @property {String} code The error code assigned to this error.\r\n * @property {String} data Additional data provided for reporting or debugging (where available).\r\n */\r\n\r\n/**\r\n * @typedef {Object} ProgressData\r\n * @property {Object} entries\r\n * @property {Number} entries.total Number of entries that have been appended.\r\n * @property {Number} entries.processed Number of entries that have been processed.\r\n * @property {Object} fs\r\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\r\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\r\n */\r\n","/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\n\r\nvar util = require('util');\r\n\r\nconst ERROR_CODES = {\r\n  'ABORTED': 'archive was aborted',\r\n  'DIRECTORYDIRPATHREQUIRED': 'diretory dirpath argument must be a non-empty string value',\r\n  'DIRECTORYFUNCTIONINVALIDDATA': 'invalid data returned by directory custom data function',\r\n  'ENTRYNAMEREQUIRED': 'entry name must be a non-empty string value',\r\n  'FILEFILEPATHREQUIRED': 'file filepath argument must be a non-empty string value',\r\n  'FINALIZING': 'archive already finalizing',\r\n  'QUEUECLOSED': 'queue closed',\r\n  'NOENDMETHOD': 'no suitable finalize/end method defined by module',\r\n  'DIRECTORYNOTSUPPORTED': 'support for directory entries not defined by module',\r\n  'FORMATSET': 'archive format already set',\r\n  'INPUTSTEAMBUFFERREQUIRED': 'input source must be valid Stream or Buffer instance',\r\n  'MODULESET': 'module already set',\r\n  'SYMLINKNOTSUPPORTED': 'support for symlink entries not defined by module',\r\n  'SYMLINKFILEPATHREQUIRED': 'symlink filepath argument must be a non-empty string value',\r\n  'SYMLINKTARGETREQUIRED': 'symlink target argument must be a non-empty string value',\r\n  'ENTRYNOTSUPPORTED': 'entry not supported'\r\n};\r\n\r\nfunction ArchiverError(code, data) {\r\n  Error.captureStackTrace(this, this.constructor);\r\n  //this.name = this.constructor.name;\r\n  this.message = ERROR_CODES[code] || code;\r\n  this.code = code;\r\n  this.data = data;\r\n}\r\n\r\nutil.inherits(ArchiverError, Error);\r\n\r\nexports = module.exports = ArchiverError;","/**\r\n * ZIP Format Plugin\r\n *\r\n * @module plugins/zip\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar engine = require('zip-stream');\r\nvar util = require('archiver-utils');\r\n\r\n/**\r\n * @constructor\r\n * @param {ZipOptions} [options]\r\n * @param {String} [options.comment] Sets the zip archive comment.\r\n * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\r\n * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.\r\n * @param {Boolean} [options.store=false] Sets the compression method to STORE.\r\n * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\r\n */\r\nvar Zip = function(options) {\r\n  if (!(this instanceof Zip)) {\r\n    return new Zip(options);\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {\r\n    comment: '',\r\n    forceUTC: false,\r\n    store: false\r\n  });\r\n\r\n  this.supports = {\r\n    directory: true,\r\n    symlink: true\r\n  };\r\n\r\n  this.engine = new engine(options);\r\n};\r\n\r\n/**\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {ZipEntryData} data\r\n * @param  {String} data.name Sets the entry name including internal path.\r\n * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.\r\n * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.\r\n * @param  {String} [data.prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @param  {fs.Stats} [data.stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n * @param  {Boolean} [data.store=ZipOptions.store] Sets the compression method to STORE.\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nZip.prototype.append = function(source, data, callback) {\r\n  this.engine.entry(source, data, callback);\r\n};\r\n\r\n/**\r\n * @return void\r\n */\r\nZip.prototype.finalize = function() {\r\n  this.engine.finalize();\r\n};\r\n\r\n/**\r\n * @return this.engine\r\n */\r\nZip.prototype.on = function() {\r\n  return this.engine.on.apply(this.engine, arguments);\r\n};\r\n\r\n/**\r\n * @return this.engine\r\n */\r\nZip.prototype.pipe = function() {\r\n  return this.engine.pipe.apply(this.engine, arguments);\r\n};\r\n\r\n/**\r\n * @return this.engine\r\n */\r\nZip.prototype.unpipe = function() {\r\n  return this.engine.unpipe.apply(this.engine, arguments);\r\n};\r\n\r\nmodule.exports = Zip;\r\n\r\n/**\r\n * @typedef {Object} ZipOptions\r\n * @global\r\n * @property {String} [comment] Sets the zip archive comment.\r\n * @property {Boolean} [forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\r\n * @property {Boolean} [forceZip64=false] Forces the archive to contain ZIP64 headers.\r\n * @property {Boolean} [store=false] Sets the compression method to STORE.\r\n * @property {Object} [zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\r\n * to control compression.\r\n * @property {*} [*] See [zip-stream]{@link https://archiverjs.com/zip-stream/ZipStream.html} documentation for current list of properties.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ZipEntryData\r\n * @global\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n * @property {Boolean} [store=ZipOptions.store] Sets the compression method to STORE.\r\n */\r\n\r\n/**\r\n * ZipStream Module\r\n * @external ZipStream\r\n * @see {@link https://www.archiverjs.com/zip-stream/ZipStream.html}\r\n */\r\n","/**\r\n * TAR Format Plugin\r\n *\r\n * @module plugins/tar\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar zlib = require('zlib');\r\n\r\nvar engine = require('tar-stream');\r\nvar util = require('archiver-utils');\r\n\r\n/**\r\n * @constructor\r\n * @param {TarOptions} options\r\n */\r\nvar Tar = function(options) {\r\n  if (!(this instanceof Tar)) {\r\n    return new Tar(options);\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {\r\n    gzip: false\r\n  });\r\n\r\n  if (typeof options.gzipOptions !== 'object') {\r\n    options.gzipOptions = {};\r\n  }\r\n\r\n  this.supports = {\r\n    directory: true,\r\n    symlink: true\r\n  };\r\n\r\n  this.engine = engine.pack(options);\r\n  this.compressor = false;\r\n\r\n  if (options.gzip) {\r\n    this.compressor = zlib.createGzip(options.gzipOptions);\r\n    this.compressor.on('error', this._onCompressorError.bind(this));\r\n  }\r\n};\r\n\r\n/**\r\n * [_onCompressorError description]\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\r\nTar.prototype._onCompressorError = function(err) {\r\n  this.engine.emit('error', err);\r\n};\r\n\r\n/**\r\n * [append description]\r\n *\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {TarEntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nTar.prototype.append = function(source, data, callback) {\r\n  var self = this;\r\n\r\n  data.mtime = data.date;\r\n\r\n  function append(err, sourceBuffer) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    self.engine.entry(data, sourceBuffer, function(err) {\r\n      callback(err, data);\r\n    });\r\n  }\r\n\r\n  if (data.sourceType === 'buffer') {\r\n    append(null, source);\r\n  } else if (data.sourceType === 'stream' && data.stats) {\r\n    data.size = data.stats.size;\r\n\r\n    var entry = self.engine.entry(data, function(err) {\r\n      callback(err, data);\r\n    });\r\n\r\n    source.pipe(entry);\r\n  } else if (data.sourceType === 'stream') {\r\n    util.collectStream(source, append);\r\n  }\r\n};\r\n\r\n/**\r\n * [finalize description]\r\n *\r\n * @return void\r\n */\r\nTar.prototype.finalize = function() {\r\n  this.engine.finalize();\r\n};\r\n\r\n/**\r\n * [on description]\r\n *\r\n * @return this.engine\r\n */\r\nTar.prototype.on = function() {\r\n  return this.engine.on.apply(this.engine, arguments);\r\n};\r\n\r\n/**\r\n * [pipe description]\r\n *\r\n * @param  {String} destination\r\n * @param  {Object} options\r\n * @return this.engine\r\n */\r\nTar.prototype.pipe = function(destination, options) {\r\n  if (this.compressor) {\r\n    return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);\r\n  } else {\r\n    return this.engine.pipe.apply(this.engine, arguments);\r\n  }\r\n};\r\n\r\n/**\r\n * [unpipe description]\r\n *\r\n * @return this.engine\r\n */\r\nTar.prototype.unpipe = function() {\r\n  if (this.compressor) {\r\n    return this.compressor.unpipe.apply(this.compressor, arguments);\r\n  } else {\r\n    return this.engine.unpipe.apply(this.engine, arguments);\r\n  }\r\n};\r\n\r\nmodule.exports = Tar;\r\n\r\n/**\r\n * @typedef {Object} TarOptions\r\n * @global\r\n * @property {Boolean} [gzip=false] Compress the tar archive using gzip.\r\n * @property {Object} [gzipOptions] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\r\n * to control compression.\r\n * @property {*} [*] See [tar-stream]{@link https://github.com/mafintosh/tar-stream} documentation for additional properties.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TarEntryData\r\n * @global\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\r\n\r\n/**\r\n * TarStream Module\r\n * @external TarStream\r\n * @see {@link https://github.com/mafintosh/tar-stream}\r\n */\r\n","/**\r\n * JSON Format Plugin\r\n *\r\n * @module plugins/json\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar inherits = require('util').inherits;\r\nvar Transform = require('readable-stream').Transform;\r\n\r\nvar crc32 = require('buffer-crc32');\r\nvar util = require('archiver-utils');\r\n\r\n/**\r\n * @constructor\r\n * @param {(JsonOptions|TransformOptions)} options\r\n */\r\nvar Json = function(options) {\r\n  if (!(this instanceof Json)) {\r\n    return new Json(options);\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {});\r\n\r\n  Transform.call(this, options);\r\n\r\n  this.supports = {\r\n    directory: true,\r\n    symlink: true\r\n  };\r\n\r\n  this.files = [];\r\n};\r\n\r\ninherits(Json, Transform);\r\n\r\n/**\r\n * [_transform description]\r\n *\r\n * @private\r\n * @param  {Buffer}   chunk\r\n * @param  {String}   encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nJson.prototype._transform = function(chunk, encoding, callback) {\r\n  callback(null, chunk);\r\n};\r\n\r\n/**\r\n * [_writeStringified description]\r\n *\r\n * @private\r\n * @return void\r\n */\r\nJson.prototype._writeStringified = function() {\r\n  var fileString = JSON.stringify(this.files);\r\n  this.write(fileString);\r\n};\r\n\r\n/**\r\n * [append description]\r\n *\r\n * @param  {(Buffer|Stream)}   source\r\n * @param  {EntryData}   data\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nJson.prototype.append = function(source, data, callback) {\r\n  var self = this;\r\n\r\n  data.crc32 = 0;\r\n\r\n  function onend(err, sourceBuffer) {\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    data.size = sourceBuffer.length || 0;\r\n    data.crc32 = crc32.unsigned(sourceBuffer);\r\n\r\n    self.files.push(data);\r\n\r\n    callback(null, data);\r\n  }\r\n\r\n  if (data.sourceType === 'buffer') {\r\n    onend(null, source);\r\n  } else if (data.sourceType === 'stream') {\r\n    util.collectStream(source, onend);\r\n  }\r\n};\r\n\r\n/**\r\n * [finalize description]\r\n *\r\n * @return void\r\n */\r\nJson.prototype.finalize = function() {\r\n  this._writeStringified();\r\n  this.end();\r\n};\r\n\r\nmodule.exports = Json;\r\n\r\n/**\r\n * @typedef {Object} JsonOptions\r\n * @global\r\n */\r\n"]}
{"version":3,"sources":["walkdir.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var EventEmitter = require('events').EventEmitter,\n_fs = require('fs'),\n_path = require('path'),\nsep = _path.sep||'/';// 0.6.x\n\n\nmodule.exports = walkdir;\n\nwalkdir.find = walkdir.walk = walkdir;\n\nwalkdir.sync = function(path,options,eventHandler){\n  if(typeof options == 'function') cb = options;\n  options = options || {};\n  options.sync = true;\n  return walkdir(path,options,eventHandler);\n};\n\n// return promise.\nwalkdir.async = function(path,options,eventHandler){\n  return new Promise((resolve,reject)=>{\n    if(typeof options == 'function') cb = options;\n    options = options || {};\n\n    let emitter = walkdir(path,options,eventHandler)\n\n    emitter.on('error',reject)\n    emitter.on('fail',(path,err)=>{\n      err.message = 'Error walking\": '+path+' '+err.message\n      if(err) reject(err)\n    })\n\n    let allPaths = {}\n    emitter.on('path',(path,stat)=>{\n      if(options.no_return !== true) allPaths[path] = stat;\n    })\n    emitter.on('end',()=>{\n      if(options.no_return !== true){\n        return resolve(options.return_object?allPaths:Object.keys(allPaths))\n      }\n      resolve()\n    })\n  })\n}\n\nfunction walkdir(path,options,cb){\n\n  if(typeof options == 'function') cb = options;\n\n  options = options || {};\n  if(options.find_links === undefined){\n    options.find_links = true;\n  }\n  \n  var fs = options.fs || _fs;\n\n  var emitter = new EventEmitter(),\n  dontTraverse = [],\n  allPaths = (options.return_object?{}:[]),\n  resolved = false,\n  inos = {},\n  stop = 0,\n  pause = null,\n  ended = 0, \n  jobs=0, \n  job = function(value) {\n    jobs += value;\n    if(value < 1 && !tick) {\n      tick = 1;\n      process.nextTick(function(){\n        tick = 0;\n        if(jobs <= 0 && !ended) {\n          ended = 1;\n          emitter.emit('end');\n        }\n      });\n    }\n  }, tick = 0;\n\n  emitter.ignore = function(path){\n    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)\n    else dontTraverse.push(path)\n    return this\n  }\n\n  //mapping is stat functions to event names.\t\n  var statIs = [['isFile','file'],['isDirectory','directory'],['isSymbolicLink','link'],['isSocket','socket'],['isFIFO','fifo'],['isBlockDevice','blockdevice'],['isCharacterDevice','characterdevice']];\n\n  var statter = function (path,first,depth) {\n    job(1);\n    var statAction = function fn(err,stat,data) {\n\n      job(-1);\n      if(stop) return;\n\n      // in sync mode i found that node will sometimes return a null stat and no error =(\n      // this is reproduceable in file descriptors that no longer exist from this process\n      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid\n      // node @ v0.6.10 \n      if(err || !stat) { \n        emitter.emit('fail',path,err);\n        return;\n      }\n\n      //if i have evented this inode already dont again.\n      var fileName = _path.basename(path);\n      var fileKey = stat.dev + '-' + stat.ino + '-' + fileName;\n      if(options.track_inodes !== false) {\n        if(inos[fileKey] && stat.ino) return;\n        inos[fileKey] = 1;\n      }\n\n      if (first && stat.isDirectory()) {\n        emitter.emit('targetdirectory',path,stat,depth);\n        return;\n      }\n\n      emitter.emit('path', path, stat, depth);\n\n      var i,name;\n\n      for(var j=0,k=statIs.length;j<k;j++) {\n        if(stat[statIs[j][0]]()) {\n          emitter.emit(statIs[j][1],path,stat,depth);\n          break;\n        }\n      }\n    };\n    \n    if(options.sync) {\n      var stat,ex;\n      try{\n        stat = fs[options.find_links?'lstatSync':'statSync'](path);\n      } catch (e) {\n        ex = e;\n      }\n\n      statAction(ex,stat);\n    } else {\n        fs[options.find_links?'lstat':'stat'](path,statAction);\n    }\n  },readdir = function(path,stat,depth){\n\n    if(!resolved) {\n      path = _path.resolve(path);\n      resolved = 1;\n    }\n\n    if(options.max_depth && depth >= options.max_depth){\n      emitter.emit('maxdepth',path,stat,depth);\n      return;\n    }\n\n    if(dontTraverse.length){\n      for(var i=0;i<dontTraverse.length;++i){\n        if(dontTraverse[i] == path) {\n          dontTraverse.splice(i,1)\n          return;\n        }\n      }\n    }\n\n    job(1);\n    var readdirAction = function(err,files) {\n      job(-1);\n      if (err || !files) {\n        //permissions error or invalid files\n        emitter.emit('fail',path,err);\n        return;\n      }\n\n      if(!files.length) {\n        // empty directory event.\n        emitter.emit('empty',path,stat,depth);\n        return;     \n      }\n\n      if(path == sep) path='';\n      if(options.filter){\n        var res = options.filter(path,files)\n        if(!res){\n          throw new Error('option.filter function must return a array of strings or a promise')\n        }\n        // support filters that return a promise\n        if(res.then){\n          job(1)\n          res.then((files)=>{\n            job(-1)\n            for(var i=0,j=files.length;i<j;i++){\n              statter(path+sep+files[i],false,(depth||0)+1);\n            }\n          })\n          return;\n        }\n        //filtered files.\n        files = res\n      }\n      for(var i=0,j=files.length;i<j;i++){\n        statter(path+sep+files[i],false,(depth||0)+1);\n      }\n\n    };\n\n\n    //use same pattern for sync as async api\n    if(options.sync) {\n      var e,files;\n      try {\n          files = fs.readdirSync(path);\n      } catch (_e) { e = _e}\n\n      readdirAction(e,files);\n    } else {\n      fs.readdir(path,readdirAction);\n    }\n  };\n\n  if (options.follow_symlinks) {\n    var linkAction = function(err,path,depth){\n      job(-1);\n      //TODO should fail event here on error?\n      statter(path,false,depth);\n    };\n\n    emitter.on('link',function(path,stat,depth){\n      job(1);\n      if(options.sync) {\n        var lpath,ex;\n        try {\n          lpath = fs.readlinkSync(path);\n        } catch(e) {\n          ex = e;\n        }\n        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);\n\n      } else {\n        fs.readlink(path,function(err,lpath){\n          linkAction(err,_path.resolve(_path.dirname(path),lpath),depth);\n        });\n      }\n    });\n  }\n\n  if (cb) {\n    emitter.on('path',cb);\n  }\n\n  if (options.sync) {\n    if(!options.no_return){\n      emitter.on('path',function(path,stat){\n        if(options.return_object) allPaths[path] = stat;\n        else allPaths.push(path);\n      });\n    }\n  }\n\n  if (!options.no_recurse) {\n    emitter.on('directory',readdir);\n  }\n  //directory that was specified by argument.\n  emitter.once('targetdirectory',readdir);\n  //only a fail on the path specified by argument is fatal \n  emitter.once('fail',function(_path,err){\n    //if the first dir fails its a real error\n    if(path == _path) {\n      emitter.emit('error',new Error('error reading first path in the walk '+path+'\\n'+err),err);\n    }\n  });\n\n  statter(path,1);\n  if (options.sync) {\n    return allPaths;\n  } else {\n    //support stopping everything.\n    emitter.end = emitter.stop = function(){stop = 1;};\n    //support pausing everything\n    var emitQ = [];\n    emitter.pause = function(){\n      job(1);\n      pause = true;\n      emitter.emit = function(){\n        emitQ.push(arguments);\n      };\n    };\n    // support getting the show going again\n    emitter.resume = function(){\n      if(!pause) return;\n      pause = false;\n      // not pending\n      job(-1);\n      //replace emit\n      emitter.emit = EventEmitter.prototype.emit;\n      // local ref\n      var q = emitQ;\n      // clear ref to prevent infinite loops\n      emitQ = [];\n      while(q.length) {\n        emitter.emit.apply(emitter,q.shift());\n      }\n    };\n\n    return emitter;\n  }\n\n}\n"]}